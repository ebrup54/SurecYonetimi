{"version":3,"file":"carousel.component.d.ts","sources":["carousel.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/***\r\n * pause (not yet supported) (?string='hover') - event group name which pauses\r\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\r\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\r\n * carousel will not react to keyboard events\r\n * note: swiping not yet supported\r\n */\r\n/****\r\n * Problems:\r\n * 1) if we set an active slide via model changes, .active class remains on a\r\n * current slide.\r\n * 2) if we have only one slide, we shouldn't show prev/next nav buttons\r\n * 3) if first or last slide is active and noWrap is true, there should be\r\n * \"disabled\" class on the nav buttons.\r\n * 4) default interval should be equal 5000\r\n */\r\nimport { EventEmitter, NgZone, OnDestroy, AfterViewInit } from '@angular/core';\r\nimport { LinkedList } from 'ngx-bootstrap/utils';\r\nimport { SlideComponent } from './slide.component';\r\nimport { CarouselConfig } from './carousel.config';\r\nimport { SlideWithIndex } from './models';\r\nexport declare enum Direction {\r\n    UNKNOWN = 0,\r\n    NEXT = 1,\r\n    PREV = 2\r\n}\r\n/**\r\n * Base element to create carousel\r\n */\r\nexport declare class CarouselComponent implements AfterViewInit, OnDestroy {\r\n    private ngZone;\r\n    noWrap: boolean;\r\n    noPause: boolean;\r\n    showIndicators: boolean;\r\n    pauseOnFocus: boolean;\r\n    indicatorsByChunk: boolean;\r\n    itemsPerSlide: number;\r\n    singleSlideOffset: boolean;\r\n    /** Turn on/off animation. Animation doesn't work for multilist carousel */\r\n    isAnimated: boolean;\r\n    /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\r\n    activeSlideChange: EventEmitter<number>;\r\n    /** Will be emitted when active slides has been changed in multilist mode */\r\n    slideRangeChange: EventEmitter<number[]>;\r\n    /** Index of currently displayed slide(started for 0) */\r\n    activeSlide: number;\r\n    startFromIndex: number;\r\n    /**\r\n     * Delay of item cycling in milliseconds. If false, carousel won't cycle\r\n     * automatically.\r\n     */\r\n    interval: number;\r\n    readonly slides: SlideComponent[];\r\n    protected currentInterval: any;\r\n    protected _currentActiveSlide: number;\r\n    protected _interval: number;\r\n    protected _slides: LinkedList<SlideComponent>;\r\n    protected _chunkedSlides: SlideWithIndex[][];\r\n    protected _slidesWithIndexes: SlideWithIndex[];\r\n    protected _currentVisibleSlidesIndex: number;\r\n    protected isPlaying: boolean;\r\n    protected destroyed: boolean;\r\n    readonly isBs4: boolean;\r\n    constructor(config: CarouselConfig, ngZone: NgZone);\r\n    ngAfterViewInit(): void;\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * Adds new slide. If this slide is first in collection - set it as active\r\n     * and starts auto changing\r\n     * @param slide\r\n     */\r\n    addSlide(slide: SlideComponent): void;\r\n    /**\r\n     * Removes specified slide. If this slide is active - will roll to another\r\n     * slide\r\n     * @param slide\r\n     */\r\n    removeSlide(slide: SlideComponent): void;\r\n    nextSlideFromInterval(force?: boolean): void;\r\n    /**\r\n     * Rolling to next slide\r\n     * @param force: {boolean} if true - will ignore noWrap flag\r\n     */\r\n    nextSlide(force?: boolean): void;\r\n    /**\r\n     * Rolling to previous slide\r\n     * @param force: {boolean} if true - will ignore noWrap flag\r\n     */\r\n    previousSlide(force?: boolean): void;\r\n    getFirstVisibleIndex(): number;\r\n    getLastVisibleIndex(): number;\r\n    getActive: (slide: SlideComponent) => boolean;\r\n    move(direction: Direction, force?: boolean): void;\r\n    /**\r\n     * Swith slides by enter, space and arrows keys\r\n     * @internal\r\n     */\r\n    keydownPress(event: KeyboardEvent): void;\r\n    /**\r\n     * Play on mouse leave\r\n     * @internal\r\n     */\r\n    onMouseLeave(): void;\r\n    /**\r\n     * Play on mouse up\r\n     * @internal\r\n     */\r\n    onMouseUp(): void;\r\n    /**\r\n     * When slides on focus autoplay is stopped(optional)\r\n     * @internal\r\n     */\r\n    pauseFocusIn(): void;\r\n    /**\r\n     * When slides out of focus autoplay is started\r\n     * @internal\r\n     */\r\n    pauseFocusOut(): void;\r\n    /**\r\n     * Rolling to specified slide\r\n     * @param index: {number} index of slide, which must be shown\r\n     */\r\n    selectSlide(index: number): void;\r\n    /**\r\n     * Starts a auto changing of slides\r\n     */\r\n    play(): void;\r\n    /**\r\n     * Stops a auto changing of slides\r\n     */\r\n    pause(): void;\r\n    /**\r\n     * Finds and returns index of currently displayed slide\r\n     */\r\n    getCurrentSlideIndex(): number;\r\n    /**\r\n     * Defines, whether the specified index is last in collection\r\n     * @param index\r\n     */\r\n    isLast(index: number): boolean;\r\n    /**\r\n     * Defines, whether the specified index is first in collection\r\n     * @param index\r\n     */\r\n    isFirst(index: number): boolean;\r\n    indicatorsSlides(): SlideComponent[];\r\n    private selectInitialSlides;\r\n    /**\r\n     * Defines next slide index, depending of direction\r\n     * @param direction: Direction(UNKNOWN|PREV|NEXT)\r\n     * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\r\n     *   return undefined if next slide require wrapping\r\n     */\r\n    private findNextSlideIndex;\r\n    private mapSlidesAndIndexes;\r\n    private selectSlideRange;\r\n    private selectRangeByNestedIndex;\r\n    private isIndexOnTheEdges;\r\n    private isIndexInRange;\r\n    private hideSlides;\r\n    private isVisibleSlideListLast;\r\n    private isVisibleSlideListFirst;\r\n    private moveSliderByOneItem;\r\n    private makeSlidesConsistent;\r\n    private moveMultilist;\r\n    private getVisibleIndexes;\r\n    /**\r\n     * Sets a slide, which specified through index, as active\r\n     * @param index\r\n     */\r\n    private _select;\r\n    /**\r\n     * Starts loop of auto changing of slides\r\n     */\r\n    private restartTimer;\r\n    readonly multilist: boolean;\r\n    /**\r\n     * Stops loop of auto changing of slides\r\n     */\r\n    private resetTimer;\r\n}\r\n"]}